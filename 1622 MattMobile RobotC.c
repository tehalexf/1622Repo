#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,	sensorQuadEncoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard			   !!*//

/*

DO NOT TOUCH

*/
#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

//Progeam Variables
int controlscheme = 0; //Controller Scheme
int debug = 0; //Debug Mode
int debugjumper = in2; //Debug Jumper (Y/N)
int statusbit = 0; //Controller Type
string mainBattery; //Main Battery Variable
string extensionBattery; //Battery Life Variables
int extensionvalue = 0; //Drive Train Battery Value
int feederOn = 0;
int pauseFeeder = 0;
int rightdrive = 0,leftdrive = 0,armup = 0,armdown = 0,reversefeeder = 0,stopFeeder = 0;


void controller_setup()
{
	if(controlscheme == 2)
	{	
		//Controller Setup
		//2 -Player
		//First Player
		//Analog Sticks
		//					 Function	   Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Ch1];//   Right Stick Right/Left (+/-)
		int /*			 */  rightdrive /**/=			/**/vexRT[Ch2];//   Right Stick Up/Down  (+/-)
		int /*			 */  leftdrive /**/=			/**/vexRT[Ch3];//   Left Stick Up/Down (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch4];//   Left Stick Right/Left (+/-)

		//Left Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7U];//   Left Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7D];//   Left Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7L];//   Left Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7R];//   Left Gamepad Right

		//Right Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8U];//   Right Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8D];//   Right Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8L];//   Right Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8R];//   Right Gamepad Right

		//Left Shoulder Buttons
		//					Function	 Reversed?
		int /*			 */  armup /**/=			/**/vexRT[Btn5U];//   Left Shoulder Up
		int /*			 */  armdown /**/=			/**/vexRT[Btn5D];//   Left Shoulder Down

			//Right Shoulder Buttons
		//					Function	 Reversed?
		int /*			 */  reversefeeder /**/=			/**/vexRT[Btn6U];//   Left Shoulder Up
		int /*			 */  stopFeeder /**/=			/**/vexRT[Btn6D];//   Left Shoulder Down

		//Second Player
		//Analog Sticks
		//					 Function	   Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Ch1Xmtr2];//   Right Stick Up/Down (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch2Xmtr2];//   Right Stick Right/Left (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch3Xmtr2];//   Left Stick Up/Down (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch4Xmtr2];//   Left Stick Right/Left (+/-)

		//Left Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7U];//   Left Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7D];//   Left Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7L];//   Left Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7R];//   Left Gamepad Right

		//Right Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8U];//   Right Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8D];//   Right Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8L];//   Right Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8R];//   Right Gamepad Right

		//Left Shoulder Buttons
		//					Function	 Reversed?
		// int /*			 */  NULL /**/=			/**/vexRT[Btn5UXmtr2];//   Left Shoulder Up
		// int /*			 */  NULL /**/=			/**/vexRT[Btn6DXmtr2];//   Left Shoulder Down

			//Right Shoulder Buttons
		//					Function	  Reversed?
		// int /*			 */  NULL  /**/=			/**/vexRT[Btn5UXmtr2];//   Left Shoulder Up
		// int /*			 */  NULL  /**/=			/**/vexRT[Btn6DXmtr2];//   Left Shoulder Down
	}
	else
	{
		//Controller Setup
		//1 -Player
		//Analog Sticks

		//					 Function	   Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Ch1];//   Right Stick Up/Down (+/-)
		int /*			 */  rightdrive /**/=			/**/vexRT[Ch2];//   Right Stick Right/Left (+/-)
		int /*			 */  leftdrive /**/=			/**/vexRT[Ch3];//   Left Stick Up/Down (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch4];//   Left Stick Right/Left (+/-)

		//Left Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7U];//   Left Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7D];//   Left Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7L];//   Left Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7R];//   Left Gamepad Right

		//Right Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8U];//   Right Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8D];//   Right Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8L];//   Right Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8R];//   Right Gamepad Right

		//Left Shoulder Buttons
		//					Function	 Reversed?
		int /*			 */  armup /**/=			/**/vexRT[Btn5U];//   Left Shoulder Up
		int /*			 */  armdown /**/=			/**/vexRT[Btn5D];//   Left Shoulder Down

			//Right Shoulder Buttons
		//					Function	 Reversed?
		int /*			 */  reversefeeder /**/=			/**/vexRT[Btn6U];//   Right Shoulder Up
		int /*			 */  stopFeeder /**/=			/**/vexRT[Btn6D];//   Right Shoulder Down
	}
}


//--Motor Mappings--
//
//	 Port	   Function			  ___________________			  ______	   ______
//	   1		Left Arm Down		|				   |			|	  |	 |	  |
//	   2		Front Right Wheel 4  |				   |  2	  7  |	  |	 |	  |  6
//	   3		Rear Right Wheel	 |		 UP		|			|  UP  |	 |  UP  |
//	   4		Front Left Wheel	 |				   |			|	  |	 |	  |
//	   5		Rear Left Wheel	  |				   |			|	  |	 |	  |		8 ---000000000000---  9
//	   6		Right Arm Up		 |				   |			|	  |	 |	  |
//	   7		Left Arm Up		  |				   |			|	  |	 |	  |
//	   8		feeder			   |				   |			|	  |	 |	  |
//	   9		feeder			   |				   |			|	  |	 |	  |
//	   10	   Right Arm Down	5  |				   |  3	  1  |	  |	 |	  |  10
//									 ---------------------			 ------	   ------
//											  Base				   Arm (Left)  Arm (Right)






//Pre-Atonomous Functions
void pre_auton()
{
	bStopTasksBetweenModes = true; //Necessary to have brain manage user created tasks
}


task autonomous()
{
	while(SensorValue[leftEncoder] <270)
	{
		if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
		{
			//do stuff
		}
		if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
		{
			//do stuff
		}
		if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
		{
			//Do stuff
		}
	}
}


void waitForPress()
{
	while(nLCDButtons == 0){} //Wait for Buttonpress
	wait1Msec(5);
}


void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}


task usercontrol()
{
	debug = 0; //Force No Debug

	//Check if Debug Jumper is inserted
	if(debugjumper == 1)
	{
		debug = 1;
	}
	else
	{
		debug = 0;
	}

	//Secret Keypress for Debug Mode Also
	if(vexRT[Btn7U] == 1 && vexRT[Btn7L] == 1 && vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1)
	{
		debug = 1;
	}
	else
	{
		debug = 0;
	}
	statusbit = nVexRCReceiveState; //Get the actual status bit data
	// Possible States Below:
	// No Crystals = 0
	// One Transmitter = 1
	// Two Transmitter = 2
	// One and Two Transmitter = 3
	// One VEXnet = 8
	// Two VEXnet = 10



	//Controller Checks
	controlscheme = 1; //Two Player Activated

	if (vexRT[Btn7DXmtr2] == 1 && vexRT[Btn8DXmtr2] == 1) //Both Buttons on partner controller 8D and 7D are pressed
	{
		controlscheme = 2; //Two Player Activated
	}

	while (true) //Actual Executable
	{
		//int /*			 */  NULL /**/=			/**/vexRT[Ch1];//   Right Stick Right/Left (+/-)
		/*			 */  rightdrive /**/=			/**/vexRT[Ch2];//   Right Stick Up/Down  (+/-)
		/*			 */  leftdrive /**/=			/**/vexRT[Ch3];//   Left Stick Up/Down (+/-)
		//int /*			 */  NULL /**/=			/**/vexRT[Ch4];//   Left Stick Right/Left (+/-)

		//Left Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7U];//   Left Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7D];//   Left Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7L];//   Left Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn7R];//   Left Gamepad Right

		//Right Gamepad
		//					Function	 Reversed?
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8U];//   Right Gamepad Up
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8D];//   Right Gamepad Down
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8L];//   Right Gamepad Left
		//int /*			 */  NULL /**/=			/**/vexRT[Btn8R];//   Right Gamepad Right

		//Left Shoulder Buttons
		//					Function	 Reversed?
		/*			 */  armup /**/=			/**/vexRT[Btn5U];//   Left Shoulder Up
		/*			 */  armdown /**/=			/**/vexRT[Btn5D];//   Left Shoulder Down

		//Right Shoulder Buttons
		//					Function	 Reversed?
		/*			 */  reversefeeder /**/=			/**/vexRT[Btn6U];//   Right Shoulder Up
		/*			 */  stopFeeder /**/=			/**/vexRT[Btn6D];//   Right Shoulder Down



		while(debug == 1) //Enter Debug Mode
		{
			bLCDBacklight = true; //Turn on LCD BackLight
			const short leftButton = 1;
			const short centerButton = 2;
			const short rightButton = 4;
			int count = 0;
			clearLCDLine(0);
			clearLCDLine(1);
			//Switching, not executing menu choices
			while(nLCDButtons != centerButton)
			{
				switch(count)
				{
					case 0: //First Choice
						displayLCDCenteredString(0, "Battery Tester");
						displayLCDCenteredString(1, "Enter");
						displayLCDChar(1, 0, 200);
						displayLCDChar(24, 0, 199);
						waitForPress();
						if(nLCDButtons == leftButton)
						{
						waitForRelease();
						count = 3; //Switch back to n-1
						}
						else if(nLCDButtons == rightButton)
						{
						waitForRelease();
						count++;
						}
						break;
					case 1: //Second Choice
						displayLCDCenteredString(0, "Distance Utility");
						displayLCDCenteredString(1, "		  Enter		 ");
						displayLCDChar(1, 0, 200);
						displayLCDChar(24, 0, 199);
						waitForPress();
						if(nLCDButtons == leftButton)
						{
						waitForRelease();
						count--;
						}
						else if(nLCDButtons == rightButton)
						{
						waitForRelease();
						count++;
						}
						break;
					case 2: //Third Choice
						displayLCDCenteredString(0, "Tilt Utility");
						displayLCDCenteredString(1, "		  Enter		 ");
						displayLCDChar(1, 0, 200);
						displayLCDChar(24, 0, 199);
						waitForPress();
						if(nLCDButtons == leftButton)
						{
						waitForRelease();
						count--;
						}
						else if(nLCDButtons == rightButton)
						{
						waitForRelease();
						count++;
						}
						break;
					case 3: //Final (4th) Choice
						displayLCDCenteredString(0, "Fap Utility");
						displayLCDCenteredString(1, "		  Enter		 ");
						displayLCDChar(1, 0, 200);
						displayLCDChar(24, 0, 199);
						waitForPress();
						if(nLCDButtons == leftButton)
						{
						waitForRelease();
						count--;
						}
						else if(nLCDButtons == rightButton)
						{
						waitForRelease();
						count = 0;
						}
						break;
					default:
						count = 0;
						break;
				} //End of Switch
			} //End of While
			//Continued Code
			clearLCDLine(0);
			clearLCDLine(1);
			//Switch Case that actually runs the user choice
			switch(count)
			{
				case 0: //Battery Tester
					while (nLCDButtons != 2)
					{
					//Battery
					displayLCDString(0, 0, "Primary: ");
					sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
					displayNextLCDString(mainBattery);
					//Second
					displayLCDString(1, 0, "Secondary: ");
					extensionvalue = (int)(SensorValue[in1]);
					sprintf(extensionBattery, "%1.2f%c",extensionvalue, 'V');	//Build the value to be displayed
					displayNextLCDString(extensionBattery);
					wait1Msec(100);
					}
					break;
				case 1: //Distance Utility
					while (nLCDButtons != 2)
					{
					//Distance sensor to be put here
					}
					break;
				case 2: //Tilt Utility
					while (nLCDButtons != 2)
					{
					//Tilt sensor to be put here
					}
					break;
				case 3: //Fap Utility
					while (nLCDButtons != 2)
					{
					//Something Else Here
					}
					break;
				default:
					displayLCDCenteredString(0, "No valid choice");
					displayLCDCenteredString(1, "was made!");
					break;
			} //End Switch
		}//End of Debug
		//Start Non-Debug Code

		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;

		if(vexRT[Ch3] > 126 && vexRT[Ch2] > 126)
		{
			if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
				motor[port3] = leftdrive*0.8;	//Front Left3
			motor[port4] = leftdrive*-0.8; //Back Left2
			motor[port5] = rightdrive*-1; //Front Right5
			motor[port2] = rightdrive*-1; //Back Right4
			if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
				motor[port3] = leftdrive;	//Front Left
			motor[port2] = leftdrive*-1; //Back Left
			motor[port5] = rightdrive*-0.8; //Front Right
			motor[port4] = rightdrive*-0.8; //Back Right
			if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
				motor[port3] = leftdrive;	//Front Left
			motor[port2] = leftdrive*-1; //Back Left
			motor[port5] = rightdrive*-1; //Front Right
			motor[port4] = rightdrive*-1; //Back Right
		}

		else if(vexRT[Ch3] > 126 && vexRT[Ch2] < -126)
		{
			if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
				motor[port3] = rightdrive*-1;	//Front Left3
			motor[port4] = rightdrive*-1; //Back Left2
			motor[port5] = leftdrive*0.8; //Front Righ5t
			motor[port2] = leftdrive*-0.8; //Back Right4
			if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
				motor[port3] = rightdrive*-0.8;	//Front Left3
			motor[port4] = rightdrive*-0.8; //Back Left2
			motor[port5] = leftdrive; //Front Righ5t
			motor[port2] = leftdrive*-1; //Back Right4
			if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
				motor[port3] = rightdrive*-1;	//Front Left3
			motor[port4] = rightdrive*-1; //Back Left2
			motor[port5] = leftdrive; //Front Righ5t
			motor[port2] = leftdrive*-1; //Back Right4
		}
		else
		{
			//Left Drivetrain
			motor[port3] = rightdrive*-1;	//Front Left3
			motor[port4] = rightdrive*-1; //Back Left2
			//Right Drivetrain
			motor[port5] = leftdrive; //Front Righ5t
			motor[port2] = leftdrive*-1; //Back Right4
		}






		//Left Arm

		//Right Arm

		//feeder Code
		//Feeder States:
		//0: Not Intalized
		//1: Intake
		//2: Paused
		//3. Reversed
		if(feederOn == 0) //Startup Code to start feeder
		{
			feederOn = 1;
		}

		if(feederOn == 1)
		{
			motor[port8] = -127;
			motor[port9] = 127;
		}

		if(feederOn == 2)
		{
			motor[port8] = 0;
			motor[port9] = 0;
		}
		if(feederOn == 3)
		{
			motor[port8] = 127;
			motor[port9] = -127;
		}

		if(reversefeeder ==1)
		{
			feederOn = 3;
		}




		if(stopFeeder == 0 && reversefeeder == 0&& pauseFeeder == 0)
		{
			feederOn = 1;
		}

		if(stopFeeder == 0 && reversefeeder == 1&& pauseFeeder == 0)
		{
			feederOn = 3;
		}

		if(stopFeeder == 0 && reversefeeder == 1&& pauseFeeder == 1)
		{
			feederOn = 3;
			pauseFeeder =0;
		}

		if(stopFeeder ==1 && time1(T1) > 200 )
		{
			if(pauseFeeder == 0)
			{
				feederOn = 2;
				ClearTimer(T1);
				pauseFeeder = 1;
			}
			else
			{
				feederOn = 1;
				ClearTimer(T1);
				pauseFeeder = 0;
			}
		}
	} //End of While
}
